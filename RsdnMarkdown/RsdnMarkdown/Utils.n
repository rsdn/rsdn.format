using Nitra;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using RsdnMarkdown.Declarations;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.WebUtility;
//using System.Web.Util.HttpEncoder; 
// TODO: Перевести на это дело!

using SCG = System.Collections.Generic;

namespace RsdnMarkdown
{
  public module Utils
  {
    public GetHtml(rsdnMarkdown : string) : string
    {
      def sb = StringBuilder();
      def reader = StringReader(rsdnMarkdown);
      def blocks = Utils.SplitQuotations(reader);
      
      def makeQuoteTree(blocks : List[_], i : int, levelNode : QuoteTree.Node) : void
      {
        when (i < 0)
          return;
          
        def (_, level, _) as content = blocks[i];
        
        if (level == levelNode.Level)
        {
          levelNode.Children.Insert(0, QuoteTree.Leaf(content));
          makeQuoteTree(blocks, i - 1, levelNode); // продолжаем перебор
        }
        else if (level > levelNode.Level)
        {
          def subLevel = QuoteTree.Node(levelNode);
          levelNode.Children.Insert(0, subLevel);
          subLevel.Children.Insert(0, QuoteTree.Leaf(content));
          makeQuoteTree(blocks, i - 1, subLevel); // входим в рекурсию
        }
        else // if (level < level.Level)
          makeQuoteTree(blocks, i, levelNode.Parent); // выходим из рекурсии
      }
      
      def root = QuoteTree.Node();
      makeQuoteTree(blocks, blocks.Count - 1, root);
      
      def makeHtml(nodes : List[QuoteTree]) : void
      {
        foreach (node in nodes)
        {
          | Leaf as x => 
            _ = sb.AppendLine(ProcessQuotationBlock(x.Text));
            
          | Node as x when x.Level > 0 =>
            _ = sb.AppendLine($<#<div class='reply-quota' data-prefix="AVK" data-level="$(x.Level)">#>);
            makeHtml(x.Children);
            _ = sb.AppendLine("</div>");
              
          | Node as x => makeHtml(x.Children);
        }
      }
      
      makeHtml(root.Children);
     
      sb.ToString()
    }
    
    public ProcessQuotationBlock(block : string) : string
    {
      def parserHost  = ParserHost();
      def sb          = StringBuilder();
      def writer      = StringWriter(sb);

      def content(contentSpan : NSpan)
      {
        def paragraph   = block.Substring(contentSpan.StartPos, contentSpan.Length);
        def source      = SingleLineSourceSnapshot(paragraph);
        def parseResult = ContentSyntax.Start(source, parserHost);
        def ast         = ContentSyntaxAst.Start.Create(parseResult);
        ast.ToHtml(writer);
      }
      
      def listStack = SCG.Stack();
      mutable prevLevel;
      mutable prevIsOrdered;
      mutable isListItem;
      mutable nestingLevel = 0;
      
      def indent(nestingLevel : int) : void
      {
        repeat (nestingLevel)
          writer.Write("  ");
      }
      def closeBlock(tag : string) : void
      {
        indent(nestingLevel);
        writer.WriteLine(tag);
      }
      def close(tag : string) : void
      {
        writer.WriteLine(tag);
      }
      def tryCloseList() : void
      {
        when (!isListItem && prevLevel > 0)
        {
          prevLevel = 0;
          prevIsOrdered = false;
          while (listStack.Count > 0)
          {
            def isOrdered = listStack.Pop();
            closeBlock(if (isOrdered) "</ol>" else "</ul>");
          }
        }
      }
      def open(tag : string) : void
      {
        tryCloseList();
        indent(nestingLevel);
        writer.Write(tag);
      }
      def openBlock(tag : string) : void
      {
        tryCloseList();
        indent(nestingLevel);
        writer.WriteLine(tag);
      }
      def openListItem(level : int, isOrdered : bool) : void
      {
        isListItem = true;
        
        if (level < prevLevel)
        {
          // Close opened lists
          for (mutable i = prevLevel; i > level; i--)
          {
            indent(nestingLevel);
            writer.WriteLine(if (prevIsOrdered) "</ol>" else "</ul>");
            nestingLevel--;
            prevIsOrdered = listStack.Pop();
            prevLevel = listStack.Count;
          }
        }
        else when (level > prevLevel)
        {
          // Open new nested list
          nestingLevel++;
          indent(nestingLevel);
          writer.WriteLine(if (isOrdered) "<ol>" else "<ul>");
          listStack.Push(prevIsOrdered);
          prevLevel = listStack.Count;
          prevIsOrdered = isOrdered;
        }

        when (prevLevel > 0 && prevLevel == level && prevIsOrdered != isOrdered)
        {
          // Lists has same level but  different oder. We should close previos list and open new one.
          indent(nestingLevel);
          writer.WriteLine(if (prevIsOrdered) "</ol>" else "</ul>");
          _ = listStack.Pop();
          listStack.Push(isOrdered);
          prevIsOrdered = isOrdered;
          indent(nestingLevel);
          writer.WriteLine(if (isOrdered) "<ol>" else "<ul>");
        }
        
        indent(nestingLevel + 1);
        writer.Write("<li>");
      }
      def foldable(header : NSpan, declarations : Seq[Paragraph]) : void
      {
        openBlock("<div class='foldable folded'>");
        nestingLevel++;
        open("<div class='block-name'>"); content(header); close("</div>");
        openBlock("<div>");
        decls(declarations);
        closeBlock("</div>");
        nestingLevel--;
        closeBlock("</div>");
      }
      and decls(paragraphs : Seq[Paragraph])
      {
        nestingLevel++;
        foreach (paragraph in paragraphs)
        {
          isListItem = false;

          match (paragraph)
          {
            | Plain             as p => open("<p>");                              content(p.Content);  close("</p>");
            | H1                as p => open("<h1>");                             content(p.Content);  close("</h1>");
            | H2                as p => open("<h2>");                             content(p.Content);  close("</h2>");
            | H3                as p => open("<h3>");                             content(p.Content);  close("</h3>");
            | H4                as p => open("<h4>");                             content(p.Content);  close("</h4>");
            | H5                as p => open("<h5>");                             content(p.Content);  close("</h5>");
            | H6                as p => open("<h6>");                             content(p.Content);  close("</h6>");
            | TagLine           as p => open("<div class='tagline'>");            content(p.Content);  close("</div>");
            | UnorderedListItem as p => openListItem(p.Level, false);             content(p.Content);  close("</li>");
            | OrderedListItem   as p => openListItem(p.Level, true);              content(p.Content);  close("</li>");
            | CodeBlock         as p => 
              if (p.Header.IsEmpty)
              {
                // Добавлять лишние переносы внутри блока кода нельзя!!! Они все отобразятся браузером.
                if (p.Lang.IsEmpty)
                  open("<div class='code'>");
                else
                {
                  def lang = block.Substring(p.Lang.StartPos, p.Lang.Length);
                  open($"<div class='code $lang'>");
                }

                def code = block.Substring(p.Code.StartPos, p.Code.Length);
                writer.Write(code);
                close("</div>");
              }
              else
              {
                def par = Paragraph.CodeBlock(p.Parent, p.Span);
                par.Initialize(p.Code, NSpan(), p.Lang); // Создаем такую же цитату, но без заголовка...
                foldable(p.Header, [par]); // ... и рекурсивно генерим для нее HTML.
              }
            | Blockquote        as p => 
              if (p.Header.IsEmpty)
              {
                openBlock("<blockquote>");
                decls(p.Content);
                closeBlock("</blockquote>");
              }
              else
              {
                def par = Paragraph.Blockquote(p.Parent, p.Span);
                par.Initialize(p.Content, NSpan()); // Создаем такую же цитату, но без заголовка...
                foldable(p.Header, [par]); // ... и рекурсивно генерим для нее HTML.
              }
              
            | FoldedBlock       as p => foldable(p.Header, p.Content);
            | Moderator         as p => openBlock("<div class='moderator'>");     decls(p.Content);    closeBlock("</div>");
            | Hr                     => tryCloseList(); writer.WriteLine(); indent(nestingLevel); writer.WriteLine("<hr>"); writer.WriteLine();
            | _ => assert2(false, "No implementation for " + paragraph.GetType().Name);
          }
          
          assert2(prevLevel >= 0);
        }
        isListItem = false;
        tryCloseList();
        nestingLevel--;
      }

      def source          = SourceSnapshot(block);
      def parseResult     = ParagraphSyntax.Start(source, parserHost);
      def declarationRoot = parseResult.GetDeclarationRoot();
      def paragraphRoot   = declarationRoot.Content :> Declarations.Root;
      decls(paragraphRoot.Paragraphs);
      sb.ToString()
    }

    public SplitQuotations(reader : TextReader) : List[string * int * string]
    {
      def blocks = List();
      mutable line;
      while ({ line = reader.ReadLine(); line != null })
      {
        def (prefix, level) = GetPrefix(line);
        blocks.Add((prefix, level, line.Substring(prefix.Length + level)));
      }

      NormalizeBlocks(blocks);
      blocks
    }
    
    public GetPrefix(line : string) : string * int
    {
      mutable bingo;

      for (mutable i = 0; i < line.Length; i++)
      {
        def ch = line[i];
        when (char.IsLetter(ch) || ch == '_')
          continue;
        def start = i;
        for (; i < line.Length; i++)
        {
          def ch = line[i];
          when (ch == '>')
          {
            bingo = true;
            continue;
          }
          
          break;
        }
        
        if (bingo)
          return (line.Substring(0, start), i - start);
        else
          return ("", 0);
      }
      
      ("", 0)
    }

    public GetUriScheme(uri : string) : string
    {
      when (uri.StartsWith("http:", StringComparison.InvariantCultureIgnoreCase))
        return "http";
      when (uri.StartsWith("https:", StringComparison.InvariantCultureIgnoreCase))
        return "https";
      
      for (mutable i = 0; i < uri.Length; i++)
      {
        def ch = uri[i];
        when (char.IsLetter(ch))
          continue;
        
        i++;
        
        when (i < uri.Length && uri[i] == ':')
          return uri.Substring(0, i - 1);
        
        return "";
      }
      
      ""
    }

    NormalizeBlocks(blocks : List[string * int * string]) : void
    {
      mutable lastPrefix;
      mutable lastLevel;
      
      def nextPrefix(blocks : List[_], mutable i : int) : string * int
      {
        for (i++; i < blocks.Count; i++)
        {
          def (prefix, level, _) = blocks[i];
          when (level > 0)
            return (prefix, level);
        }
        
        (null, 0)
      }
      
      for (mutable i = 0; i < blocks.Count; i++)
      {
        def (prefix, level, text) = blocks[i];
        
        if (prefix == "" && string.IsNullOrWhiteSpace(text))
        {
          def (nextPrefix, nextLevel) = nextPrefix(blocks, i);
          when (nextPrefix == lastPrefix && nextLevel == lastLevel)
            blocks[i] = (lastPrefix, lastLevel, text);
        }
        else
        {
          lastPrefix = prefix;
          lastLevel  = level;
        }
      }

      lastPrefix = null;
      def parts = List();
      for (mutable i = 0; i < blocks.Count; i++)
      {
        def (prefix, level, _) = blocks[i];

        for (mutable j = i + 1; j < blocks.Count; j++)
        {
          def (nextPrefix, nextLevel, nextText) = blocks[j];

          if (prefix == nextPrefix && level == nextLevel)
            parts.Add(nextText);
          else
            break;
        }

        when (parts.Count > 0)
        {
          blocks.RemoveRange(i + 1, parts.Count);
          def (_, _, text) = blocks[i];
          parts.Insert(0, text);
          blocks[i] = (prefix, level, string.Join(Environment.NewLine, parts));
          parts.Clear();
        }

        lastPrefix = prefix;
      }
    }
    
    internal ProcessContent(writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      def str = ast.GetText(span);
      HtmlEncode(str, writer);
    }

    internal ProcessContent(tag : string, writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      writer.Write("<");
      writer.Write(tag);
      writer.Write(">");
      HtmlEncode(ast.GetText(span), writer);
      writer.Write("</");
      writer.Write(tag);
      writer.Write(">");
    }

    internal ProcessAutoUri(writer : TextWriter, ast : Ast) : void
    {
      def url = ast.GetText();
      def urlSource = url.TrimEnd('.', ',', ')');

      ProcessUrl(writer, urlSource, urlSource);
      
      when (url.Length > urlSource.Length)
      {
        def suffix = url.Substring(urlSource.Length, url.Length - urlSource.Length);
        HtmlEncode(suffix, writer);
      }
    }

    internal ProcessUri(writer : TextWriter, imgOpt : OptionAst[NSpan], urlTextOpt : OptionAst[SequenceAst[ContentSyntaxAst.UrlText, NSpan]], url : ContentSyntaxAst.Url) : void
    {
      def urlSource = url.GetText().Trim();
      def urlSource = if (GetUriScheme(urlSource).Length == 0) "http://" + urlSource else urlSource;

      if (imgOpt.HasValue)
      {
        when (imgOpt.Location.GetText() == "+!")
        {
          // Вот здесь нужно сгенерировать хтмл скрывающегося блока
          // class='foldable'
        }
        writer.Write(<#<img src="#>);
        HtmlAttributeEncode(writer, urlSource);
        writer.Write("\" ");
        when (urlTextOpt.HasValue)
        {
          def urlText = HtmlAttributeEncode(urlTextOpt.Value.Item1.GetText());
          writer.Write($<#title="$urlText" alt="$urlText" #>);
        }
        writer.Write(">");
      }
      else
        ProcessUrl(writer, urlSource, if (urlTextOpt.HasValue) urlTextOpt.Value.Item1.GetText() else url.GetText())
    }
    
    ProcessUrl(writer : TextWriter, urlSource : string, displayText :string) : void
    {
      writer.Write(<#<a href="#>);
      HtmlAttributeEncode(writer, urlSource);
      writer.Write(<#">#>);
      def urlText = HtmlEncode(displayText);
      writer.Write(urlText);
      writer.Write(<#</a>#>);
    }

    internal HtmlAttributeEncode(writer : TextWriter, str : string) : void
    {
      writer.Write(HtmlAttributeEncode(str));
    }
    
    internal HtmlAttributeEncode(str : string) : string
    {
      str.Replace("\"", "&quot;")
    }
    
    internal ProcessSmile(writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      match (ast.GetText(span))
      {
        | <#:)#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/smile.gif">#>);
        | <#:))#>       => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/biggrin.gif">#>);
        | <#:)))#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/lol.gif">#>);
        | <#:(#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/frown.gif">#>);
        | <#;)#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/wink.gif">#>);
        | <#:-\#>       => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/smirk.gif">#>);
        | <#:???:#>     => writer.Write(<#<img border="0" width="15" height="22" src="http://rsdn.ru/Forum/Images/confused.gif">#>);
        | <#:no:#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/no.gif">#>);
        | <#:up:#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/sup.gif">#>);
        | <#:down:#>    => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/down.gif">#>);
        | <#:super:#>   => writer.Write(<#<img border="0" width="26" height="28" src="http://rsdn.ru/Forum/Images/super.gif">#>);
        | <#:shuffle:#> => writer.Write(<#<img border="0" width="15" height="20" src="http://rsdn.ru/Forum/Images/shuffle.gif">#>);
        | <#:wow:#>     => writer.Write(<#<img border="0" width="19" height="19" src="http://rsdn.ru/Forum/Images/wow.gif">#>);
        | <#:crash:#>   => writer.Write(<#<img border="0" width="30" height="30" src="http://rsdn.ru/Forum/Images/crash.gif">#>);
        | <#:user:#>    => writer.Write(<#<img border="0" width="40" height="20" src="http://rsdn.ru/Forum/Images/user.gif">#>);
        | <#:maniac:#>  => writer.Write(<#<img border="0" width="70" height="25" src="http://rsdn.ru/Forum/Images/maniac.gif">#>);
        | <#:xz:#>      => writer.Write(<#<img border="0" width="37" height="15" src="http://rsdn.ru/Forum/Images/xz.gif">#>);
        | <#:beer:#>    => writer.Write(<#<img border="0" width="57" height="16" src="http://rsdn.ru/Forum/Images/beer.gif">#>);
        | text          => HtmlEncode(text, writer);
      }
    }
    
    // TODO: Сделать поддержку таблиц
    
    internal ProcessCode(writer : TextWriter, ast : Ast, languageName : NSpan, code : NSpan) : void
    {
      // TODO: Сделать версию для инлайн и отдельного блока кода.
      def lang = 
        match (ast.GetText(languageName))
        {
          | "C#" | "c#"   => "cs"
          | "C++" | "c++" => "cpp"
          | txt           => txt
        };
      writer.Write($<#<span class="code $lang">#>);
      HtmlEncode(ast.GetText(code), writer);
      writer.Write("</span>");
    }
    
    internal ProcessAutoCorrect(writer : TextWriter, ast : Ast, ws1 : NSpan, text : NSpan, ws2 : NSpan) : void
    {
      writer.Write(ast.GetText(ws1));
      match (ast.GetText(text))
      {
        | "--" => writer.Write("–");
        | str => HtmlEncode(str, writer);
      }
      writer.Write(ast.GetText(ws2));
    }

    internal BeginQuotes(writer : TextWriter, ch : char) : void
    {
      writer.Write(<#<span class="inline-quote">#>);
      writer.Write(ch);
    }

    internal EndQuotes(writer : TextWriter, ch : char) : void
    {
      writer.Write(ch);
      writer.Write(<#</span>#>);
    }
  }
}
