using Nitra;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using RsdnMarkdown.Declarations;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.WebUtility;
//using System.Web.Util.HttpEncoder; 
// TODO: Перевести на это дело!

using SCG = System.Collections.Generic;

namespace RsdnMarkdown
{
  public module Utils
  {
    public ProcessQuotationBlock(block : string) : string
    {
      def parserHost  = ParserHost();
      def sb          = StringBuilder();
      def writer      = StringWriter(sb);

      def content(contentSpan : NSpan)
      {
        def paragraph   = block.Substring(contentSpan.StartPos, contentSpan.Length);
        def source      = SingleLineSourceSnapshot(paragraph);
        def parseResult = ContentSyntax.Start(source, parserHost);
        def ast         = ContentSyntaxAst.Start.Create(parseResult);
        ast.ToHtml(writer);
      }
      
      def listStack = SCG.Stack();
      mutable prevLevel;
      mutable prevIsOrdered;
      mutable isListItem;
      mutable nestingLevel = 0;
      
      def indent(nestingLevel : int) : void
      {
        repeat (nestingLevel)
          writer.Write("  ");
      }
      def closeBlock(tag : string) : void
      {
        indent(nestingLevel);
        writer.WriteLine(tag);
      }
      def close(tag : string) : void
      {
        writer.WriteLine(tag);
      }
      def tryCloseList() : void
      {
        when (!isListItem && prevLevel > 0)
        {
          prevLevel = 0;
          prevIsOrdered = false;
          while (listStack.Count > 0)
          {
            def isOrdered = listStack.Pop();
            closeBlock(if (isOrdered) "</ol>" else "</ul>");
          }
        }
      }
      def open(tag : string) : void
      {
        tryCloseList();
        indent(nestingLevel);
        writer.Write(tag);
      }
      def openBlock(tag : string) : void
      {
        tryCloseList();
        indent(nestingLevel);
        writer.WriteLine(tag);
      }
      def openListItem(level : int, isOrdered : bool) : void
      {
        isListItem = true;
        
        if (level < prevLevel)
        {
          // Close opened lists
          for (mutable i = prevLevel; i > level; i--)
          {
            indent(nestingLevel);
            writer.WriteLine(if (prevIsOrdered) "</ol>" else "</ul>");
            nestingLevel--;
            prevIsOrdered = listStack.Pop();
            prevLevel = listStack.Count;
          }
        }
        else when (level > prevLevel)
        {
          // Open new nested list
          nestingLevel++;
          indent(nestingLevel);
          writer.WriteLine(if (isOrdered) "<ol>" else "<ul>");
          listStack.Push(prevIsOrdered);
          prevLevel = listStack.Count;
          prevIsOrdered = isOrdered;
        }

        when (prevLevel > 0 && prevLevel == level && prevIsOrdered != isOrdered)
        {
          // Lists has same level but  different oder. We should close previos list and open new one.
          indent(nestingLevel);
          writer.WriteLine(if (prevIsOrdered) "</ol>" else "</ul>");
          _ = listStack.Pop();
          listStack.Push(isOrdered);
          prevIsOrdered = isOrdered;
          indent(nestingLevel);
          writer.WriteLine(if (isOrdered) "<ol>" else "<ul>");
        }
        
        indent(nestingLevel + 1);
        writer.Write("<li>");
      }
      def foldable(header : NSpan, declarations : Seq[Paragraph]) : void
      {
        openBlock("<div class='foldable folded'>");
        nestingLevel++;
        open("<div class='block-name'>"); content(header); close("</div>");
        openBlock("<div>");
        decls(declarations);
        closeBlock("</div>");
        nestingLevel--;
        closeBlock("</div>");
      }
      and decls(paragraphs : Seq[Paragraph])
      {
        nestingLevel++;
        foreach (paragraph in paragraphs)
        {
          isListItem = false;

          match (paragraph)
          {
            | Plain             as p => open("<p>");                              content(p.Content);  close("</p>");
            | H1                as p => open("<h1>");                             content(p.Content);  close("</h1>");
            | H2                as p => open("<h2>");                             content(p.Content);  close("</h2>");
            | H3                as p => open("<h3>");                             content(p.Content);  close("</h3>");
            | H4                as p => open("<h4>");                             content(p.Content);  close("</h4>");
            | H5                as p => open("<h5>");                             content(p.Content);  close("</h5>");
            | H6                as p => open("<h6>");                             content(p.Content);  close("</h6>");
            | TagLine           as p => open("<div class='tagline'>");            content(p.Content);  close("</div>");
            | UnorderedListItem as p => openListItem(p.Level, false);             content(p.Content);  close("</li>");
            | OrderedListItem   as p => openListItem(p.Level, true);              content(p.Content);  close("</li>");
            | Blockquote        as p => 
              if (p.Header.IsEmpty)
              {
                openBlock("<blockquote>");
                decls(p.Content);
                closeBlock("</blockquote>");
              }
              else
              {
                def par = Paragraph.Blockquote(p.Parent, p.Span);
                par.Initialize(p.Content, NSpan()); // Создаем такую же цитату, но без заголовка...
                foldable(p.Header, [par]); // ... и рекурсивно генерим для нее HTML.
              }
              
            | FoldedBlock       as p => foldable(p.Header, p.Content);
            | Moderator         as p => openBlock("<div class='moderator'>");     decls(p.Content);    closeBlock("</div>");
            | Hr                     => writer.WriteLine(); indent(nestingLevel); writer.WriteLine("<hr>"); writer.WriteLine();
            | _ => assert2(false, "No implementation for " + paragraph.GetType().Name);
          }
          
          assert2(prevLevel >= 0);
        }
        isListItem = false;
        tryCloseList();
        nestingLevel--;
      }

      def source          = SourceSnapshot(block);
      def parseResult     = ParagraphSyntax.Start(source, parserHost);
      def declarationRoot = parseResult.GetDeclarationRoot();
      def paragraphRoot   = declarationRoot.Content :> Declarations.Root;
      decls(paragraphRoot.Paragraphs);

      sb.ToString()
    }

    public SplitQuotations(reader : TextReader) : List[KeyValuePair[string, string]]
    {
      def blocks = List();
      mutable line;
      while ({ line = reader.ReadLine(); line != null })
      {
        def prefix = GetPrefix(line);
        blocks.Add(KeyValuePair(prefix, line.Substring(prefix.Length)));
      }

      NormalizeBlocks(blocks);
      blocks
    }
    
    public GetPrefix(line : string) : string
    {
      mutable bingo;
      
      for (mutable i = 0; i < line.Length; i++)
      {
        def ch = line[i];
        when (char.IsLetter(ch) || ch == '_')
          continue;
        
        for (; i < line.Length; i++)
        {
          def ch = line[i];
          when (ch == '>')
          {
            bingo = true;
            continue;
          }
          
          break;
        }
        
        if (bingo)
          return line.Substring(0, i);
        else
          return "";
      }
      
      ""
    }
    
    public GetUriScheme(uri : string) : string
    {
      when (uri.StartsWith("http:", StringComparison.InvariantCultureIgnoreCase))
        return "http";
      when (uri.StartsWith("https:", StringComparison.InvariantCultureIgnoreCase))
        return "https";
      
      for (mutable i = 0; i < uri.Length; i++)
      {
        def ch = uri[i];
        when (char.IsLetter(ch))
          continue;
        
        i++;
        
        when (i < uri.Length && uri[i] == ':')
          return uri.Substring(0, i - 1);
        
        return "";
      }
      
      ""
    }
    
    NormalizeBlocks(blocks : List[KeyValuePair[string, string]]) : void
    {
      mutable lastPrefix;
      def nextPrefix(blocks : List[_], mutable i : int) : string
      {
        for (i++; i < blocks.Count; i++)
        {
          def prefix = blocks[i].Key;
          when (prefix != "")
            return prefix;
        }
        
        null
      }
      
      for (mutable i = 0; i < blocks.Count; i++)
      {
        def prefix = blocks[i].Key;
        def text = blocks[i].Value;
        
        if (prefix == "" && string.IsNullOrWhiteSpace(text))
        {
          def nextPrefix = nextPrefix(blocks, i);
          when (nextPrefix == lastPrefix)
          {
            blocks[i] = KeyValuePair(lastPrefix, text);
          }
        }
        else
          lastPrefix = prefix;
      }
      
      lastPrefix = null;
      def parts = List();
      for (mutable i = 0; i < blocks.Count; i++)
      {
        def prefix = blocks[i].Key;
        
        for (mutable j = i + 1; j < blocks.Count; j++)
        {
          def nextPrefix = blocks[j].Key;

          if (prefix == nextPrefix)
            parts.Add(blocks[j].Value);
          else
            break;
        }
        
        when (parts.Count > 0)
        {
          blocks.RemoveRange(i + 1, parts.Count);
          parts.Insert(0, blocks[i].Value);
          blocks[i] = KeyValuePair(prefix, string.Join(Environment.NewLine, parts));
          parts.Clear();
        }
        
        lastPrefix = prefix;
      }
    }
    
    internal ProcessContent(writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      def str = ast.GetText(span);
      HtmlEncode(str, writer);
    }

    internal ProcessContent(tag : string, writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      writer.Write("<");
      writer.Write(tag);
      writer.Write(">");
      HtmlEncode(ast.GetText(span), writer);
      writer.Write("</");
      writer.Write(tag);
      writer.Write(">");
    }
    
    internal ProcessUri(writer : TextWriter, imgOpt : OptionAst[NSpan], urlTextOpt : OptionAst[SequenceAst[ContentSyntaxAst.UrlText, NSpan]], url : ContentSyntaxAst.Url) : void
    {
      def urlSource = url.GetText().Trim();
      def urlSource = if (GetUriScheme(urlSource).Length == 0) "http://" + urlSource else urlSource;

      if (imgOpt.HasValue)
      {
        when (imgOpt.Location.GetText() == "+!")
        {
          // Вот здесь нужно сгенерировать хтмл скрывающегося блока
          // class='foldable'
        }
        writer.Write(<#<img src="#>);
        HtmlAttributeEncode(writer, urlSource);
        writer.Write("\" ");
        when (urlTextOpt.HasValue)
        {
          def urlText = HtmlAttributeEncode(urlTextOpt.Value.Item1.GetText());
          writer.Write($<#title="$urlText" alt="$urlText" #>);
        }
        writer.Write(">");
      }
      else
      {
        writer.Write(<#<a href="#>);
        HtmlAttributeEncode(writer, urlSource);
        writer.Write(<#">#>);
        def urlText = HtmlEncode(if (urlTextOpt.HasValue) urlTextOpt.Value.Item1.GetText() else url.GetText());
        writer.Write(urlText);
        writer.Write(<#</a>#>);
      }
    }

    internal HtmlAttributeEncode(writer : TextWriter, str : string) : void
    {
      writer.Write(HtmlAttributeEncode(str));
    }
    
    internal HtmlAttributeEncode(str : string) : string
    {
      str.Replace("\"", "&quot;")
    }
    
    internal ProcessSmile(writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      match (ast.GetText(span))
      {
        | <#:)#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/smile.gif">#>);
        | <#:))#>       => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/biggrin.gif">#>);
        | <#:)))#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/lol.gif">#>);
        | <#:(#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/frown.gif">#>);
        | <#;)#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/wink.gif">#>);
        | <#:-\#>       => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/smirk.gif">#>);
        | <#:???:#>     => writer.Write(<#<img border="0" width="15" height="22" src="http://rsdn.ru/Forum/Images/confused.gif">#>);
        | <#:no:#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/no.gif">#>);
        | <#:up:#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/sup.gif">#>);
        | <#:down:#>    => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/down.gif">#>);
        | <#:super:#>   => writer.Write(<#<img border="0" width="26" height="28" src="http://rsdn.ru/Forum/Images/super.gif">#>);
        | <#:shuffle:#> => writer.Write(<#<img border="0" width="15" height="20" src="http://rsdn.ru/Forum/Images/shuffle.gif">#>);
        | <#:wow:#>     => writer.Write(<#<img border="0" width="19" height="19" src="http://rsdn.ru/Forum/Images/wow.gif">#>);
        | <#:crash:#>   => writer.Write(<#<img border="0" width="30" height="30" src="http://rsdn.ru/Forum/Images/crash.gif">#>);
        | <#:user:#>    => writer.Write(<#<img border="0" width="40" height="20" src="http://rsdn.ru/Forum/Images/user.gif">#>);
        | <#:maniac:#>  => writer.Write(<#<img border="0" width="70" height="25" src="http://rsdn.ru/Forum/Images/maniac.gif">#>);
        | <#:xz:#>      => writer.Write(<#<img border="0" width="37" height="15" src="http://rsdn.ru/Forum/Images/xz.gif">#>);
        | <#:beer:#>    => writer.Write(<#<img border="0" width="57" height="16" src="http://rsdn.ru/Forum/Images/beer.gif">#>);
        | text          => HtmlEncode(text, writer);
      }
    }
    
    // TODO: Сделать поддержку таблиц
    
    internal ProcessCode(writer : TextWriter, ast : Ast, languageName : NSpan, code : NSpan) : void
    {
      // TODO: Сделать версию для инлайн и отдельного блока кода.
      def lang = 
        match (ast.GetText(languageName))
        {
          | "C#" | "c#"   => "cs"
          | "C++" | "c++" => "cpp"
          | txt           => txt
        };
      writer.Write($<#<code class="code $lang">#>);
      HtmlEncode(ast.GetText(code), writer);
      writer.Write("</code>");
    }
    
    internal ProcessAutoCorrect(writer : TextWriter, ast : Ast, ws1 : NSpan, text : NSpan, ws2 : NSpan) : void
    {
      writer.Write(ast.GetText(ws1));
      match (ast.GetText(text))
      {
        | "--" => writer.Write("–");
        | str => HtmlEncode(str, writer);
      }
      writer.Write(ast.GetText(ws2));
    }

    internal BeginQuotes(writer : TextWriter, ch : char) : void
    {
      writer.Write(<#<span class="inline-quote">#>);
      writer.Write(ch);
    }
    internal EndQuotes(writer : TextWriter, ch : char) : void
    {
      writer.Write(ch);
      writer.Write(<#</span>#>);
    }
  }
}
