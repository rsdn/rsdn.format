using Nitra;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using RsdnMarkdown.Declarations;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.WebUtility;

using SCG = System.Collections.Generic;

namespace RsdnMarkdown
{
  public module Utils
  {
    public ProcessQuotationBlock(block : string) : List[string]
    {
      def parserHost  = ParserHost();
      def sb          = StringBuilder();
      def writer      = StringWriter(sb);
      def result      = List();

      def processContent(contentSpan : NSpan)
      {
        def paragraph   = block.Substring(contentSpan.StartPos, contentSpan.Length);
        def source      = SingleLineSourceSnapshot(paragraph);
        def parseResult = ContentSyntax.Start(source, parserHost);
        def ast         = ContentSyntaxAst.Start.Create(parseResult);
        sb.Length = 0;
        ast.ToHtml(writer);
      }
      
      def listStack = SCG.Stack();
      mutable prevLevel;
      mutable prevIsOrdered;
      def closeList()
      {
      }
      def preList(level : int, isOrdered : bool) : void
      {
        when (prevLevel > 0 && prevLevel == level && prevIsOrdered != isOrdered)
        {
          // Списки на одном урочне, но с разным типом нумерации
          writer.Write(if (prevIsOrdered) "<ol>" else "<ul>");
          _ = listStack.Pop();
          listStack.Push(isOrdered);
          prevIsOrdered = isOrdered;
          writer.Write(if (isOrdered) "<ol>" else "<ul>");
          return;
        }
        
        if (level < prevLevel)
        {
          writer.Write(if (prevIsOrdered) "</ol>" else "</ul>");
          prevIsOrdered = listStack.Pop();
          prevLevel = listStack.Count;
        }
        else when (level > prevLevel)
        {
          writer.Write(if (isOrdered) "<ol>" else "<ul>");
          listStack.Push(isOrdered);
          prevLevel = listStack.Count;
        }
      }
      
      def processDecls(paragraphs : DeclarationList[Paragraph])
      {
        foreach (paragraph in paragraphs)
        {
          mutable currentLevel;
          
          match (paragraph)
          {
            | H1                as p => writer.Write("<h1>");              processContent(p.Content);    writer.Write("</h1>");
            | H2                as p => writer.Write("<h2>");              processContent(p.Content);    writer.Write("</h2>");
            | H3                as p => writer.Write("<h3>");              processContent(p.Content);    writer.Write("</h3>");
            | H4                as p => writer.Write("<h4>");              processContent(p.Content);    writer.Write("</h4>");
            | H5                as p => writer.Write("<h5>");              processContent(p.Content);    writer.Write("</h5>");
            | H6                as p => writer.Write("<h6>");              processContent(p.Content);    writer.Write("</h6>");
            | TagLine           as p => writer.Write("<TagLine>");         processContent(p.Content);    writer.Write("</TagLine>");
            | Blockquote        as p => writer.WriteLine("<blockquote>");  processDecls(p.Content);              writer.WriteLine("</blockquote>");
            | FoldedBlock       as p => writer.WriteLine("<div>");         processDecls(p.Content);              writer.WriteLine("</div>");
            | Moderator         as p => writer.WriteLine("<div>");         processDecls(p.Content);              writer.WriteLine("</div>");
            | UnorderedListItem as p => preList(p.Level, false);   writer.Write("<li>");              processContent(p.Content);    writer.Write("</li>");
            | OrderedListItem   as p => preList(p.Level, false);   writer.Write("<li>");              processContent(p.Content);    writer.Write("</li>");
            | Hr                     => writer.Write("<hr>");
            | _ => ()
          }
        }
      }

      def source          = SourceSnapshot(block);
      def parseResult     = ParagraphSyntax.Start(source, parserHost);
      def declarationRoot = parseResult.GetDeclarationRoot();
      def paragraphRoot   = declarationRoot.Content :> Declarations.Root;
      processDecls(paragraphRoot.Paragraphs);

      result
    }

    public SplitQuotations(reader : TextReader) : List[KeyValuePair[string, string]]
    {
      def blocks = List();
      mutable line;
      while ({ line = reader.ReadLine(); line != null })
      {
        def prefix = GetPrefix(line);
        blocks.Add(KeyValuePair(prefix, line.Substring(prefix.Length)));
      }

      NormalizeBlocks(blocks);
      blocks
    }
    
    public GetPrefix(line : string) : string
    {
      mutable bingo;
      
      for (mutable i = 0; i < line.Length; i++)
      {
        def ch = line[i];
        when (char.IsLetter(ch) || ch == '_')
          continue;
        
        for (; i < line.Length; i++)
        {
          def ch = line[i];
          when (ch == '>')
          {
            bingo = true;
            continue;
          }
          
          break;
        }
        
        if (bingo)
          return line.Substring(0, i);
        else
          return "";
      }
      
      ""
    }
    
    public GetUriScheme(uri : string) : string
    {
      when (uri.StartsWith("http:", StringComparison.InvariantCultureIgnoreCase))
        return "http";
      when (uri.StartsWith("https:", StringComparison.InvariantCultureIgnoreCase))
        return "https";
      
      for (mutable i = 0; i < uri.Length; i++)
      {
        def ch = uri[i];
        when (char.IsLetter(ch))
          continue;
        
        i++;
        
        when (i < uri.Length && uri[i] == ':')
          return uri.Substring(0, i - 1);
        
        return "";
      }
      
      ""
    }
    
    NormalizeBlocks(blocks : List[KeyValuePair[string, string]]) : void
    {
      mutable lastPrefix;
      def nextPrefix(blocks : List[_], mutable i : int) : string
      {
        for (i++; i < blocks.Count; i++)
        {
          def prefix = blocks[i].Key;
          when (prefix != "")
            return prefix;
        }
        
        null
      }
      
      for (mutable i = 0; i < blocks.Count; i++)
      {
        def prefix = blocks[i].Key;
        def text = blocks[i].Value;
        
        if (prefix == "" && string.IsNullOrWhiteSpace(text))
        {
          def nextPrefix = nextPrefix(blocks, i);
          when (nextPrefix == lastPrefix)
          {
            blocks[i] = KeyValuePair(lastPrefix, text);
          }
        }
        else
          lastPrefix = prefix;
      }
      
      lastPrefix = null;
      def parts = List();
      for (mutable i = 0; i < blocks.Count; i++)
      {
        def prefix = blocks[i].Key;
        
        for (mutable j = i + 1; j < blocks.Count; j++)
        {
          def nextPrefix = blocks[j].Key;

          if (prefix == nextPrefix)
            parts.Add(blocks[j].Value);
          else
            break;
        }
        
        when (parts.Count > 0)
        {
          blocks.RemoveRange(i + 1, parts.Count);
          parts.Insert(0, blocks[i].Value);
          blocks[i] = KeyValuePair(prefix, string.Join(Environment.NewLine, parts));
          parts.Clear();
        }
        
        lastPrefix = prefix;
      }
    }
    
    internal ProcessContent(writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      def str = ast.GetText(span);
      HtmlEncode(str, writer);
    }

    internal ProcessContent(tag : string, writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      writer.Write("<");
      writer.Write(tag);
      writer.Write(">");
      HtmlEncode(ast.GetText(span), writer);
      writer.Write("</");
      writer.Write(tag);
      writer.Write(">");
    }
    
    internal ProcessUri(writer : TextWriter, imgOpt : OptionAst[NSpan], urlTextOpt : OptionAst[SequenceAst[ContentSyntaxAst.UrlText, NSpan]], url : ContentSyntaxAst.Url) : void
    {
      def urlSource = url.GetText().Trim();
      def urlSource = if (GetUriScheme(urlSource).Length == 0) "http://" + urlSource else urlSource;

      if (imgOpt.IsSome)
      {
        writer.Write(<#<img src="#>);
        HtmlAttributeEncode(writer, urlSource);
        writer.Write("\" ");
        when (urlTextOpt.IsSome)
        {
          def urlText = HtmlAttributeEncode(urlTextOpt.Item.Item1.GetText());
          writer.Write($<#title="$urlText" alt="$urlText" #>);
        }
        writer.Write(">");
      }
      else
      {
        writer.Write(<#<a href="#>);
        HtmlAttributeEncode(writer, urlSource);
        writer.Write(<#">#>);
        def urlText = HtmlEncode(if (urlTextOpt.IsSome) urlTextOpt.Item.Item1.GetText() else url.GetText());
        writer.Write(urlText);
        writer.Write(<#</a>#>);
      }
    }

    internal HtmlAttributeEncode(writer : TextWriter, str : string) : void
    {
      writer.Write(HtmlAttributeEncode(str));
    }
    
    internal HtmlAttributeEncode(str : string) : string
    {
      str.Replace("\"", "&quot;")
    }
    
    internal ProcessSmile(writer : TextWriter, ast : Ast, span : NSpan) : void
    {
      match (ast.GetText(span))
      {
        | <#:)#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/smile.gif">#>);
        | <#:))#>       => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/biggrin.gif">#>);
        | <#:)))#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/lol.gif">#>);
        | <#:(#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/frown.gif">#>);
        | <#;)#>        => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/wink.gif">#>);
        | <#:-\#>       => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/smirk.gif">#>);
        | <#:???:#>     => writer.Write(<#<img border="0" width="15" height="22" src="http://rsdn.ru/Forum/Images/confused.gif">#>);
        | <#:no:#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/no.gif">#>);
        | <#:up:#>      => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/sup.gif">#>);
        | <#:down:#>    => writer.Write(<#<img border="0" width="15" height="15" src="http://rsdn.ru/Forum/Images/down.gif">#>);
        | <#:super:#>   => writer.Write(<#<img border="0" width="26" height="28" src="http://rsdn.ru/Forum/Images/super.gif">#>);
        | <#:shuffle:#> => writer.Write(<#<img border="0" width="15" height="20" src="http://rsdn.ru/Forum/Images/shuffle.gif">#>);
        | <#:wow:#>     => writer.Write(<#<img border="0" width="19" height="19" src="http://rsdn.ru/Forum/Images/wow.gif">#>);
        | <#:crash:#>   => writer.Write(<#<img border="0" width="30" height="30" src="http://rsdn.ru/Forum/Images/crash.gif">#>);
        | <#:user:#>    => writer.Write(<#<img border="0" width="40" height="20" src="http://rsdn.ru/Forum/Images/user.gif">#>);
        | <#:maniac:#>  => writer.Write(<#<img border="0" width="70" height="25" src="http://rsdn.ru/Forum/Images/maniac.gif">#>);
        | <#:xz:#>      => writer.Write(<#<img border="0" width="37" height="15" src="http://rsdn.ru/Forum/Images/xz.gif">#>);
        | <#:beer:#>    => writer.Write(<#<img border="0" width="57" height="16" src="http://rsdn.ru/Forum/Images/beer.gif">#>);
        | text          => HtmlEncode(text, writer);
      }
    }
    
    internal ProcessCode(writer : TextWriter, ast : Ast, languageName : NSpan, code : NSpan) : void
    {
      writer.Write($<#<span class="code" lang="$(ast.GetText(languageName))">#>);
      HtmlEncode(ast.GetText(code), writer);
      writer.Write("</span>");
    }
    
    internal ProcessAutoCorrect(writer : TextWriter, ast : Ast, ws1 : NSpan, text : NSpan, ws2 : NSpan) : void
    {
      writer.Write(ast.GetText(ws1));
      match (ast.GetText(text))
      {
        | "--" => writer.Write("–");
        | str => HtmlEncode(str, writer);
      }
      writer.Write(ast.GetText(ws2));
    }

    internal BeginQuotes(writer : TextWriter, ch : char) : void
    {
      writer.Write(<#<span class="inline-quote">#>);
      writer.Write(ch);
    }
    internal EndQuotes(writer : TextWriter, ch : char) : void
    {
      writer.Write(ch);
      writer.Write(<#</span>#>);
    }
  }
}
